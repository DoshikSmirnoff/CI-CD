Это фреймворк для тестирования

Устанвливается через консоль при помощи ввода pip install pytest
Тестовые функции создаются в отдельных папках проекта, в котором создаются тестовые файлы с неймингом "test_*что-то/например,наименование файла, который тестируется*"

Для тестирования файлов из других файлов создаем в папке venv файл pytest.ini, в котором прописываем:
```
[pytest]
pythonpath = . # наименование папки/файла, которую(ый) хотим перенести в глобальную область видимости для тестирования
```
После этого в файле с тестами вверху прописываем 
```
from # (наименование папки.наименование файла) import (функцию или класс, который тестируется)
```

# Пирамида тестирования

### Ручное тестирование
Тестирование работы кода (этим занимаются QA-инженеры)

### E2E (End to end) тесты / сквозные тесты
Тесты проверяют работу приложения в целом / весь пользовательский путь

### Integration тесты
Интеграционные тесты проверяют как взаимодействуют между собой компоненты системы (DB, API, services)
Не запускаются параллельно, для них часто нужна инфраструктура (например, БД/Redis)

### Unit-тесты / модульные тесты
Пишутся для отдельно взятой функции/модуля/класса, чтобы проверить технокорректность работы
Модульных тестов больше всего, на них строятся все остальные тесты
Работают в вакууме/изоляции от всего остального, их можно прогонять параллельно, так как друг от друга они не зависят

# Настройка Pycharm для удобного тестирования
Для появления раннеров (зеленые play-треугольники) надо зайти в file settings, в поиске ввести runner, выбрать в default test runner - pytest, нажать ОК
Это позволяет запускать тесты без использования консоли

# Параметризация тестов
Импортируется pytest и на тест навешивается декоратор @pytest.mark.parametrize(), в скобках которого указывает аргументы/параметры, наборы значений в виде списка кортежей

Пример: 
```
@pytest.mark.parametrize(
    "x, y, res",
    [
      (1, 2, 0.5),
      (5, -1, -5)
    ])

def test_devide(x, y, res):
    assert Calculator().divide(x, y) == res

# В данном примере сразу обрабатывается два тестовых случая, проходит два теста 
```
Для запуска теста в консоли прописываем pytest и в результатах будет две точки - значит, что оба теста завершены успешно (оба теста - потому что уазаны два кейса)
Для детализации кесов тестов в консоли надо прописать pytest через флаг -v, то есть pytest -v

# Группировка тестов
Для группировки тестов они оборачиваются в классы 

Пример: 
```
class TestCalculator:
    @pytest.mark.parametrize(
    "x, y, res",
    [
      (1, 2, 0.5),
      (5, -1, -5)
    ])
    def test_devide(x, y, res):
        assert Calculator().divide(x, y) == res

    @pytest.mark.parametrize(
    "x, y, res",
    [
      (1, 2, 3),
      (5, -1, 4)
    ])
    def test_add(x, y, res):
        assert Calculator().add(x, y) == res
```
Для запуска всех тестов в группе TestCalculator в консоли прописываем pytest и далее адрес этого теста (например, tests(папка)/test_main.py(файл с тестами)::TestCalculator)

# Обработка исключений
Прописываем в начале файла from contextlib import nullcontext as does_not_raise

Пример: 
```
from contextlib import nullcontext as does_not_raise

@pytest.mark.parametrize(
    "x, y, res, expectation",
    [
      (1, 2, 0.5, does_not_raise()),
      (5, -1, -5, does_not_raise()),
      (5, "-1", -5, pytest.raises(TypeError))
    ])

def test_devide(x, y, res, expectation):
    with expectation:
        assert Calculator().divide(x, y) == res
```

### Фикстуры
- функции, которые выполняют подготовительные действия перед запуском тестов
Наиболее частые кейсы:
1) тестовые http-клиенты
2) коннекторы к БД

# Параметр SCOPE в фикстурах
Фикстура может принимать в себя как другие фикстуры, так и параметр scope
Данный параметр показывает насколько долго живет фикстура и может принимать 4 значения:
- session (фикстура создается и уничтожается один раз для всей сессии тестов)
- module (фикстура живет в рамках одного тестового модуля)
- function (фикстура живет в рамках одной тестовой функции)
- class (фикстура живет в рамках одного тестового класса)

# Область примененипя фикстур и AAA
В фикстуры выносятся только наиболее часто повторяющиеся блоки кода
Если есть тест, в котором надо сделать что-то только один раз, то тест пишется согласно паттерну AAA 

AAA (Arrange, Act, Assert)
Arrange - организовать: в этом этапе подготавливаются все необходимые данные и настройки теста
Act - выполнить: здесь мы выполняем действие, которое хотим протестировать
Assert - проверить: на этом этапе проверяется, сответствует ли результат теста ожидаемому результату

# Pytest плагины
- инструменты, которые позволяют расширять функциональность фреймворка и настраивать его поведение для конкретных задач и проектов

# Pytest mark
- функционал, который позволяет помечать тестовые функции и классы тестов, чтобы добавлять дополнительную информацию о тестах и управлять их выполнением

# Faker
Позволяет быстро генерировать фейковые данные для тестов





















